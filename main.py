from math import sqrt

"""
 Что можно изменить:
 - добавить вывод промежуточных результатов
 Создать массив списокв. Для каждой пары списков подсчитать 
 индекс Жаккарта или Пирсона
 Сделать функцию, которая будет для данного списка из массива списков 
 выдавать похожие списки + коэфф + номер
 
"""

# я не понял, почему у Сорокина в лекции двумя способами считается индекс
# Жаккарда
# На всякий случай сделал оба
# Первый способ: ( количество положительных совпадений
# + количество отрицательных совпадений ) / общее количество элементов в списках
#
# Второй способ: размер пересечения / размер объединения
#
# В чем отличие? Во втором способе не учитываются негативные совпадения
# т.е совпадения 0 = 0

def jaccard_index_1(A, B):
    acc = 0
    # Подсчеь одинаковых действий
    for i, j in zip(A, B):
        if i == j:
            acc += 1
    n = min(len(A), len(B))

    return acc / n

def jaccard_index_2(A, B):
    s_intersect = sum(map(lambda tup: 1 if tup[0] and tup[1] else 0, zip(A, B)))
    s_union = sum(map(lambda tup: 1 if tup[0] or tup[1] else 0, zip(A, B)))
    return s_intersect / s_union


def pearson(A, B):
    # это я так, от себя добавил
    # на случай, если списки не совпадают по длине
    n = min(len(A), len(B))
    A = A[:n]
    B = B[:n]

    # средняя оценка для каждого пользователя
    avg_a = sum(A) / n
    avg_b = sum(B) / n

    # отклонение от средней оценки
    r_a = [value - avg_a for value in A]
    r_b = [value - avg_b for value in B]

    # Сумма произведений отклонений
    numerator = sum(
                    map(
                        lambda tup: tup[0] * tup[1],
                        zip(r_a, r_b)
                    )
                )

    # Произведение из корней из суммы квадратов отклонений
    denominator = sqrt(sum(map(lambda x: x**2, r_a))) \
                * sqrt(sum(map(lambda y: y**2, r_b)))
    return numerator / denominator


# Первый пример из лецит
print(jaccard_index_1([1, 1, 1, 0, 0, 0],
        [1, 1, 0, 1, 0, 0])
      )

# Второй пример из лекции
print(jaccard_index_2([1, 1, 1, 0, 0, 0],
        [1, 1, 0, 1, 0, 0])
      )

# Единственный пример в лекции. Ответ не совпадает, т.к в лекции ошибка
print(pearson([4, 5, 4, 4, 3, 3],
              [3, 3, 3, 2, 4, 5]))